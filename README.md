# AuthPI
[![.github/workflows/node.js.yml](https://github.com/TheLe0/AuthPI/actions/workflows/node.js.yml/badge.svg)](https://github.com/TheLe0/AuthPI/actions/workflows/node.js.yml)

AuthPI is a REST API made on Node for authenticate and authorize users.

## Prerequisites

1. Node
2. Yarn
3. Docker
4. Npx

## Installation

1. Create a ```.env``` file on the project root, and set the enviroment variables like the ```.env-example``` file.

Where:

* <b>SERVER</B> the host that is going to run the application, if is local you can put ```localhost``` or ```127.0.0.1```.

* <b>PORT</B> the server port to listen your application, normally is used ```3000```, ```8000``` or ```8080```. You must validate before if is already something running in this port on your machine, if so, the application is not going to run.

* <b>DATABASE_URL</B> this is generated by prisma when you start the migration, is the connection string to the ORM connect to your database, is something like this ```postgresql://postgres:postgres@localhost:5432/USER_API?schema=public```.

* <b>SALT</B> this is a number where you specify the number of rounds of the salt when you use bcrypt.

* <b>JWT_SECRET</B> this is the symetric key for generate the JWT tokens, the algorithm used was the default, SHA256, and its use only on key (symetric). The tests was build using ```EQrsJ1qzQW``` as the key. If you are going to use another, change the JWTs used as mock on the tests.

* <b>JWT_EXPIRATION</B> time in seconds for the token to expire, used ```84600``` as example.

2. Run ```yarn``` for install all the dependencies of the project.

3. Run ```docker-compose up -d``` to create the container for the postgres database. And create a new database named ```USER_API```.

4. Run the prisma migrations ```npx prisma migrate dev -d```, this is going to execute all the migrations, creating all the database structure.

5. Execute the tests ```yarn test``` to see if is everything fine and working.

6. Now you can run the application, in development mode ```yarn start:dev``` or in production mode ```yarn start:prod```.

## Database Structure

+ User

| Field        | Type       |  Constraints       |
|--------------|------------|--------------------|
| id           | uuid       |     Primary Key    |
| email        | string     |     Unique         |
| name         | string     |                    |
| role         | string     |                    |

+ Token

| Field        | Type       |  Constraints       |
|--------------|------------|--------------------|
| id           | uuid       |     Primary Key    |
| userId       | uuid       |     Foreign Key    |
| refreshToken | string     |                    |
| device       | string     |                    |
| expiration   | datetime   |                    |

## Endpoints

Here is where is described all the application endpoints, parameters and bodies.

> Note:
> All the endpoints, except the login one is needed to
> use a Bearer authentication token. This token you 
> receive as the response for the login endpoint

### GET

* ```/``` : The home endpoint, only used to see if the server is up and running.

* ```/user``` : List all the users stored in the database.
The response of this endpoint is something like this:

```json
[
	{
		"name": "User name 1",
		"email": "user1@email",
		"role": "some_role"
	},
    {
		"name": "User name 2",
		"email": "user2@email",
		"role": "some_another_role"
	}
]
```

* ```/user/:email/``` : Find a user by his email. The response of this endpoint is something like this:

```json
{
    "name": "User name 1",
    "email": "user1@email",
    "role": "some_role"
}
```

* ```/users/:role/``` : List all users with a specific role. The response of this endpoint is something like this:

```json
[
	{
		"name": "User name 1",
		"email": "user1@email",
		"role": "some_role"
	},
    {
		"name": "User name 2",
		"email": "user2@email",
		"role": "some_role"
	}
]
```

### POST

* ```/user/login``` : Endpoint for doing the login.

The request body is something like this:

```json
{
    "email": "user1@email",
    "password": "my_password"
}
```

And the response, if the credentials match with the database, is going to generate the JWT token to be used in the other endpoints as authentication.

```json
{
	"token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjp7Im5hbWUiOiJMZW9uYXJkbyAgVG9zaW4iLCJlbWFpbCI6ImxidG9zaW5AdWNzLmJyIiwicm9sZSI6InN5c2FkbWluIn0sImlhdCI6MTYzOTk1NzI5NywiZXhwIjoxNjQwMDQxODk3fQ.nxeKM_gkncrH9BfLBHZ95AjIjsajj47WeMQI3drLrcU"
}
```

* ```/user``` : Endpoint for create a new user in the database.

Request body:


```json
{
	"email": "user@email.com",
	"name": "User name",
	"role": "some_role",
	"password": "user_password"
}
```

And the response is going to be the user created, only with the public fields, id and password are private.


```json
{
	"email": "user@email.com",
	"name": "User name",
	"role": "some_role"
}
```

### PUT

* ```/user``` : Update all the public information of the user (email, name and role). The update is by the email on the claims of the JWT used for the request.

Request body:


```json
{
	"email": "user@email.com",
	"name": "User name",
	"role": "some_role"
}
```

And the response is going to return with the same fields as the request.


```json
{
	"email": "user@email.com",
	"name": "User name",
	"role": "some_role"
}
```

### PATCH

The <b>PATCH</b> REST method, is similar as the <b>UPDATE</b> one, but the update is for updating all the fields, and patch just some specific one.

* ```/user``` : Endpoint for change the user password. Like the update one, the user that is going to be affected is the one of the email on the JWT.

Request body:


```json
{
	"old_password": "123",
	"new_password": "321"
}
```

And the response is going to return a status code 202 with a message that the execution was successfully completed.

```json
{
	"The password was successfully updated!"
}
```

### DELETE

* ```/user/:email/``` : Delete a user by the email on the endpoint. The response of the request is going to be a status code 202 with the following message:

```json
{
	"The user was successfully deleted!"
}
```

## Next Steps

The project is not over, there are some new features that are going to be featured on the next versions:

- [ ] Use redis to cache the information
- [ ] Implement refresh tokens
